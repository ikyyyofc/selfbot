// plugins/claude.js
import axios from 'axios';
import upload from '../lib/upload.js';

export default async function ({ m, text, fileBuffer, reply }) {
  if (!text) {
    return reply("Silakan berikan pertanyaan Anda setelah perintah. Contoh: .claude Apa kabar?");
  }

  const payload = {
    text: text,
    systemPrompt: "bot.js:\nimport \"./config.js\";\nimport colors from \"@colors/colors/safe.js\";\nimport BotState from \"./lib/BotState.js\";\nimport PluginManager from \"./lib/PluginManager.js\";\nimport ConnectionManager from \"./lib/ConnectionManager.js\";\n\n// ===== MAIN =====\nconst main = async () => {\n    console.log(colors.cyan(\"ü§ñ Starting bot...\\n\"));\n\n    const state = new BotState();\n    const pluginManager = new PluginManager(state);\n    const connectionManager = new ConnectionManager(state, pluginManager);\n\n    await connectionManager.connect();\n};\n\nmain().catch(error => {\n    console.error(colors.red(\"‚ùå Fatal error:\"), error);\n    process.exit(0);\n});\n\nlib/AntiDeleteEditHandler.js:\nimport { jidNormalizedUser, downloadMediaMessage } from \"@whiskeysockets/baileys\";\nimport Pino from \"pino\";\nimport colors from \"@colors/colors/safe.js\";\n\nclass AntiDeleteEditHandler {\n    constructor(state) {\n        this.state = state;\n    }\n\n    async handleUpdate(sock, update) {\n        try {\n            const messageId = update.key.id;\n            const from = update.key.remoteJid.endsWith(\"broadcast\")\n                ? jidNormalizedUser(sock.user.id)\n                : update.key.remoteJid;\n\n            const isStatus = update.key.remoteJid.endsWith(\"broadcast\");\n            const isGroup = from.endsWith(\"@g.us\");\n            if (isGroup) return;\n\n            const storedData = this.state.messageStore.get(messageId);\n            if (!storedData || storedData.message.key.fromMe) return;\n\n            // Check for deletion\n            if (\n                update.update?.message === null ||\n                update.update?.messageStubType === 68\n            ) {\n                await this.handleDelete(sock, from, storedData, isStatus);\n            }\n            // Check for edit\n            else if (\n                update.update?.message?.editedMessage ||\n                update.update?.message?.protocolMessage?.type === 14\n            ) {\n                await this.handleEdit(\n                    sock,\n                    from,\n                    messageId,\n                    storedData,\n                    update\n                );\n            }\n        } catch (error) {\n            console.error(\n                colors.red(\"‚ùå Anti-delete/edit error:\"),\n                error.message\n            );\n        }\n    }\n\n    async handleDelete(sock, from, storedData, isStatus) {\n        console.log(colors.magenta(`üóëÔ∏è Message deleted detected`));\n\n        const storedMessage = storedData.message;\n        const sender = storedMessage.sender;\n        const senderName = storedMessage.pushName || sender.split(\"@\")[0];\n\n        const lastMessage = storedData.editHistory\n            ? storedData.editHistory[storedData.editHistory.length - 1].message\n            : storedMessage.message;\n\n        const messageInfo = this.getMessageInfo(lastMessage);\n        let antiDeleteMsg = this.buildDeleteMessage(\n            isStatus,\n            senderName,\n            sender,\n            storedMessage,\n            storedData,\n            messageInfo\n        );\n\n        await sock.sendMessage(from, { text: antiDeleteMsg });\n        await this.resendMedia(sock, from, storedMessage);\n    }\n\n    async handleEdit(sock, from, messageId, storedData, update) {\n        console.log(colors.yellow(`‚úèÔ∏è Message edited detected`));\n\n        const storedMessage = storedData.message;\n        const sender =\n            storedMessage.key.participant || storedMessage.key.remoteJid;\n        const senderName = storedMessage.pushName || sender.split(\"@\")[0];\n\n        const oldContent = this.getOldContent(storedData);\n        const { newContent, newMessageObj } = this.getNewContent(update);\n        const messageType = this.getMessageType(storedMessage.message);\n        const editCount = (storedData.editHistory?.length || 0) + 1;\n\n        const antiEditMsg = this.buildEditMessage(\n            senderName,\n            sender,\n            storedMessage,\n            messageType,\n            editCount,\n            oldContent,\n            newContent\n        );\n\n        await sock.sendMessage(from, { text: antiEditMsg });\n        this.state.addEditHistory(messageId, newMessageObj);\n    }\n\n    getMessageInfo(message) {\n        const content =\n            message?.conversation ||\n            message?.extendedTextMessage?.text ||\n            message?.imageMessage?.caption ||\n            message?.videoMessage?.caption ||\n            message?.documentMessage?.caption ||\n            \"\";\n\n        return {\n            content,\n            hasSticker: !!message?.stickerMessage,\n            hasImage: !!message?.imageMessage,\n            hasVideo: !!message?.videoMessage,\n            hasAudio: !!message?.audioMessage,\n            hasDocument: !!message?.documentMessage\n        };\n    }\n\n    buildDeleteMessage(\n        isStatus,\n        senderName,\n        sender,\n        storedMessage,\n        storedData,\n        messageInfo\n    ) {\n        let msg = `üö´ *${isStatus ? \"STATUS\" : \"PESAN\"} DIHAPUS*\\n\\n`;\n        msg += `üë§ Pengirim: ${senderName}\\n`;\n        msg += `üì± Nomor: ${sender.split(\"@\")[0]}\\n`;\n        msg += `‚è∞ Waktu: ${new Date(\n            storedMessage.messageTimestamp * 1000\n        ).toLocaleString(\"id-ID\", {\n            timeZone: \"Asia/Jakarta\"\n        })}\\n`;\n\n        if (storedData.editHistory?.length > 0) {\n            msg += `\\nüìù *Riwayat Edit (${storedData.editHistory.length}x):*\\n`;\n            storedData.editHistory.forEach((edit, index) => {\n                const content =\n                    this.getMessageInfo(edit.message).content ||\n                    \"(media/sticker)\";\n                msg += `\\n${index + 1}. ${content}\\n   ‚è∞ ${new Date(\n                    edit.timestamp\n                ).toLocaleString(\"id-ID\", {\n                    timeZone: \"Asia/Jakarta\"\n                })}`;\n            });\n            msg += `\\n`;\n        } else {\n            msg += `\\n`;\n        }\n\n        if (messageInfo.content) {\n            msg += `üìù *Pesan Terakhir:*\\n${messageInfo.content}`;\n        } else if (messageInfo.hasSticker) {\n            msg += `üé≠ Tipe: Stiker`;\n        } else if (messageInfo.hasImage) {\n            msg += `üñºÔ∏è Tipe: Gambar`;\n        } else if (messageInfo.hasVideo) {\n            msg += `üé• Tipe: Video`;\n        } else if (messageInfo.hasAudio) {\n            msg += `üéµ Tipe: Audio`;\n        } else if (messageInfo.hasDocument) {\n            msg += `üìÑ Tipe: Dokumen`;\n        }\n\n        return msg;\n    }\n\n    buildEditMessage(\n        senderName,\n        sender,\n        storedMessage,\n        messageType,\n        editCount,\n        oldContent,\n        newContent\n    ) {\n        let msg = `‚úèÔ∏è *PESAN DIEDIT*\\n\\n`;\n        msg += `üë§ Pengirim: ${senderName}\\n`;\n        msg += `üì± Nomor: ${sender.split(\"@\")[0]}\\n`;\n\n        if (messageType !== \"teks\") {\n            msg += `üì¶ Tipe: ${messageType}\\n`;\n        }\n\n        msg += `‚è∞ Waktu Original: ${new Date(\n            storedMessage.messageTimestamp * 1000\n        ).toLocaleString(\"id-ID\", {\n            timeZone: \"Asia/Jakarta\"\n        })}\\n`;\n        msg += `‚è∞ Waktu Edit: ${new Date().toLocaleString(\"id-ID\", {\n            timeZone: \"Asia/Jakarta\"\n        })}\\n\\n`;\n        msg += `üî¢ Edit ke-${editCount}\\n\\n`;\n\n        const label = messageType !== \"teks\" ? \"Caption\" : \"Pesan\";\n        msg += `üìù ${label} Lama:\\n${oldContent}\\n\\n`;\n        msg += `‚ú® ${label} Baru:\\n${newContent}`;\n\n        return msg;\n    }\n\n    getOldContent(storedData) {\n        if (storedData.editHistory?.length > 0) {\n            const lastEdit =\n                storedData.editHistory[storedData.editHistory.length - 1];\n            return this.getMessageInfo(lastEdit.message).content || \"(kosong)\";\n        }\n        return (\n            this.getMessageInfo(storedData.message.message).content ||\n            \"(kosong)\"\n        );\n    }\n\n    getNewContent(update) {\n        let newContent = \"(kosong)\";\n        let newMessageObj = null;\n\n        if (update.update.message?.editedMessage) {\n            const editedMsg = update.update.message.editedMessage.message;\n            if (editedMsg) {\n                newMessageObj = editedMsg;\n                newContent =\n                    this.getMessageInfo(editedMsg).content || \"(kosong)\";\n            }\n        } else if (update.update.message?.protocolMessage) {\n            const editedMsg =\n                update.update.message.protocolMessage.editedMessage;\n            if (editedMsg) {\n                newMessageObj = editedMsg;\n                newContent =\n                    this.getMessageInfo(editedMsg).content || \"(kosong)\";\n            }\n        }\n\n        return { newContent, newMessageObj };\n    }\n\n    getMessageType(message) {\n        if (message?.imageMessage) return \"üñºÔ∏è Gambar\";\n        if (message?.videoMessage) return \"üé• Video\";\n        if (message?.documentMessage) return \"üìÑ Dokumen\";\n        if (message?.audioMessage) return \"üéµ Audio\";\n        if (message?.stickerMessage) return \"üé≠ Stiker\";\n        return \"teks\";\n    }\n\n    async resendMedia(sock, from, storedMessage) {\n        const originalMessage = storedMessage.message;\n        const downloadOptions = {\n            logger: Pino({ level: \"silent\" }),\n            reuploadRequest: sock.updateMediaMessage\n        };\n\n        try {\n            if (originalMessage?.stickerMessage) {\n                const buffer = await downloadMediaMessage(\n                    storedMessage,\n                    \"buffer\",\n                    {},\n                    downloadOptions\n                );\n                await sock.sendMessage(from, { sticker: buffer });\n            } else if (originalMessage?.imageMessage) {\n                const buffer = await downloadMediaMessage(\n                    storedMessage,\n                    \"buffer\",\n                    {},\n                    downloadOptions\n                );\n                await sock.sendMessage(from, {\n                    image: buffer,\n                    caption: \"üñºÔ∏è Gambar yang dihapus\"\n                });\n            } else if (originalMessage?.videoMessage) {\n                const buffer = await downloadMediaMessage(\n                    storedMessage,\n                    \"buffer\",\n                    {},\n                    downloadOptions\n                );\n                await sock.sendMessage(from, {\n                    video: buffer,\n                    caption: \"üé• Video yang dihapus\"\n                });\n            } else if (originalMessage?.audioMessage) {\n                const buffer = await downloadMediaMessage(\n                    storedMessage,\n                    \"buffer\",\n                    {},\n                    downloadOptions\n                );\n                await sock.sendMessage(from, {\n                    audio: buffer,\n                    mimetype: \"audio/mp4\"\n                });\n            } else if (originalMessage?.documentMessage) {\n                const buffer = await downloadMediaMessage(\n                    storedMessage,\n                    \"buffer\",\n                    {},\n                    downloadOptions\n                );\n                await sock.sendMessage(from, {\n                    document: buffer,\n                    mimetype: originalMessage.documentMessage.mimetype,\n                    fileName: originalMessage.documentMessage.fileName,\n                    caption: \"üìÑ Dokumen yang dihapus\"\n                });\n            }\n        } catch (e) {\n            console.error(colors.red(\"‚ùå Failed to resend media:\"), e.message);\n        }\n    }\n}\n\nexport default AntiDeleteEditHandler;\n\nlib/BotState.js:\nimport fs from \"fs\";\nimport path from \"path\";\nimport colors from \"@colors/colors/safe.js\";\n\nconst config = await import(\"../config.js\").then(m => m.default);\n\nconst MESSAGE_STORE_LIMIT = 1000;\nconst MESSAGE_STORE_FILE = path.join(config.SESSION, \"message_store.json\");\nconst MESSAGE_SAVE_INTERVAL = 10;\n\nclass BotState {\n    constructor() {\n        this.plugins = new Map();\n        this.messageStore = this.loadMessageStore();\n        this.messageCounter = 0;\n    }\n\n    loadMessageStore() {\n        try {\n            if (fs.existsSync(MESSAGE_STORE_FILE)) {\n                const data = fs.readFileSync(MESSAGE_STORE_FILE, \"utf8\");\n                const parsed = JSON.parse(data);\n                const store = new Map(Object.entries(parsed));\n                console.log(\n                    colors.cyan(`üíæ Loaded ${store.size} messages from storage`)\n                );\n                return store;\n            }\n        } catch (error) {\n            console.error(\n                colors.red(\"‚ùå Failed to load message store:\"),\n                error.message\n            );\n        }\n        return new Map();\n    }\n\n    saveMessageStore() {\n        try {\n            const obj = Object.fromEntries(this.messageStore);\n            fs.writeFileSync(MESSAGE_STORE_FILE, JSON.stringify(obj, null, 2));\n        } catch (error) {\n            console.error(\n                colors.red(\"‚ùå Failed to save message store:\"),\n                error.message\n            );\n        }\n    }\n\n    addMessage(messageId, data) {\n        if (this.messageStore.size >= MESSAGE_STORE_LIMIT) {\n            const firstKey = this.messageStore.keys().next().value;\n            this.messageStore.delete(firstKey);\n        }\n\n        this.messageStore.set(messageId, data);\n        this.messageCounter++;\n\n        if (this.messageCounter % MESSAGE_SAVE_INTERVAL === 0) {\n            this.saveMessageStore();\n        }\n    }\n\n    addEditHistory(messageId, newMessage) {\n        const storedData = this.messageStore.get(messageId);\n        if (!storedData) return;\n\n        if (!storedData.editHistory) {\n            storedData.editHistory = [];\n        }\n\n        const editCount = storedData.editHistory.length + 1;\n        storedData.editHistory.push({\n            message: newMessage,\n            timestamp: Date.now(),\n            editNumber: editCount\n        });\n\n        this.messageStore.set(messageId, storedData);\n        this.saveMessageStore();\n    }\n}\n\nexport default BotState;\n\nlib/ConnectionManager.js:\nimport makeWASocket, {\n    Browsers,\n    useMultiFileAuthState,\n    makeCacheableSignalKeyStore,\n    fetchLatestWaWebVersion\n} from \"@whiskeysockets/baileys\";\nimport Pino from \"pino\";\nimport { Boom } from \"@hapi/boom\";\nimport fs from \"fs\";\nimport colors from \"@colors/colors/safe.js\";\nimport readline from \"readline\";\nimport MessageHandler from \"./MessageHandler.js\";\nimport AntiDeleteEditHandler from \"./AntiDeleteEditHandler.js\";\nimport { extendSocket } from \"./socket.js\";\nimport groupCache from \"./groupCache.js\";\nimport sessionCleaner from \"./SessionCleaner.js\";\n\nconst config = await import(\"../config.js\").then(m => m.default);\n\nclass ConnectionManager {\n    constructor(state, pluginManager) {\n        this.state = state;\n        this.pluginManager = pluginManager;\n        this.messageHandler = new MessageHandler(state, pluginManager);\n        this.antiDeleteEditHandler = new AntiDeleteEditHandler(state);\n    }\n\n    async getPairingCode() {\n        return new Promise(resolve => {\n            const rl = readline.createInterface({\n                input: process.stdin,\n                output: process.stdout\n            });\n\n            rl.question(\n                colors.yellow(\n                    \"üì± Masukkan nomor WhatsApp (contoh: 628123456789): \"\n                ),\n                answer => {\n                    rl.close();\n                    resolve(answer.trim());\n                }\n            );\n        });\n    }\n\n    async connect() {\n        await this.pluginManager.loadPlugins();\n        console.log(colors.green(\"Connecting...\"));\n\n        // Start session cleaner\n        sessionCleaner.start();\n        sessionCleaner.logStats();\n\n        const { version, isLatest } = await fetchLatestWaWebVersion();\n        console.log(\n            colors.green(`Using version: ${version}\\nLatest: ${isLatest}`)\n        );\n\n        const { state, saveCreds } = await useMultiFileAuthState(\n            config.SESSION\n        );\n\n        const sock = makeWASocket({\n            auth: {\n                creds: state.creds,\n                keys: makeCacheableSignalKeyStore(\n                    state.keys,\n                    Pino().child({ level: \"fatal\", stream: \"store\" })\n                )\n            },\n            browser: Browsers.ubuntu(\"Chrome\"),\n            logger: Pino({ level: \"silent\" }),\n            syncFullHistory: false,\n            markOnlineOnConnect: false,\n            generateHighQualityLinkPreview: true,\n            version,\n            // Use cached group metadata\n            cachedGroupMetadata: async jid => groupCache.get(jid)\n        });\n\n        // Extend socket with helper functions\n        await extendSocket(sock);\n\n        // Handle pairing\n        if (!sock.authState.creds.registered) {\n            setTimeout(async () => {\n                try {\n                    const pairingNumber = await this.getPairingCode();\n\n                    if (!pairingNumber || pairingNumber.length < 10) {\n                        console.error(colors.red(\"‚ùå Nomor tidak valid!\"));\n                        process.exit(1);\n                    }\n\n                    const code = await sock.requestPairingCode(\n                        pairingNumber,\n                        config.PAIRING_CODE\n                    );\n                    console.log(\n                        colors.green(`\\n‚úÖ Pairing Code: `) +\n                            colors.yellow.bold(code)\n                    );\n                    console.log(\n                        colors.cyan(\"üì≤ Masukkan kode ini di WhatsApp kamu\\n\")\n                    );\n                } catch (err) {\n                    console.error(`Failed to get pairing code: ${err}`);\n                }\n            }, 3000);\n        }\n\n        sock.ev.on(\"creds.update\", saveCreds);\n        sock.ev.on(\"connection.update\", update =>\n            this.handleConnectionUpdate(update, sock)\n        );\n        sock.ev.on(\"messages.upsert\", async ({ messages }) => {\n            await this.messageHandler.handleMessage(sock, messages[0]);\n        });\n        sock.ev.on(\"messages.update\", async updates => {\n            for (const update of updates) {\n                await this.antiDeleteEditHandler.handleUpdate(sock, update);\n            }\n        });\n\n        // Handle group participants update (for cache sync)\n        sock.ev.on(\n            \"group-participants.update\",\n            async ({ id, participants, action }) => {\n                console.log(\n                    colors.cyan(\n                        `üë• Group participants update: ${action} in ${id}`\n                    )\n                );\n\n                if (action === \"add\") {\n                    groupCache.addParticipants(id, participants);\n                } else if (action === \"remove\") {\n                    groupCache.removeParticipants(id, participants);\n                } else if (action === \"promote\" || action === \"demote\") {\n                    // Refresh metadata to get updated admin status\n                    await groupCache.fetch(sock, id, true);\n                }\n            }\n        );\n\n        // Handle group update (subject, description, etc)\n        sock.ev.on(\"groups.update\", async updates => {\n            for (const update of updates) {\n                console.log(colors.cyan(`üîÑ Group update: ${update.id}`));\n\n                if (update.subject) {\n                    groupCache.updateSubject(update.id, update.subject);\n                }\n\n                // Refresh full metadata for other changes\n                if (update.desc || update.restrict || update.announce) {\n                    await groupCache.fetch(sock, update.id, true);\n                }\n            }\n        });\n\n        this.setupGracefulShutdown();\n    }\n\n    async handleConnectionUpdate(update, sock) {\n        const { connection, lastDisconnect } = update;\n\n        if (connection === \"open\") {\n            console.log(\n                colors.green(\"‚úÖ Connected as \") + colors.cyan(sock.user.name)\n            );\n        }\n\n        if (connection === \"close\") {\n            const statusCode = new Boom(lastDisconnect?.error)?.output\n                ?.statusCode;\n\n            if (\n                statusCode === 401 ||\n                statusCode === 403 ||\n                statusCode === 405\n            ) {\n                console.warn(\n                    colors.red(\n                        `‚ö†Ô∏è Session invalid (${statusCode}), resetting...`\n                    )\n                );\n                fs.rmSync(`./${config.SESSION}`, {\n                    recursive: true,\n                    force: true\n                });\n            } else {\n                console.log(colors.yellow(\"üîÑ Reconnecting...\"));\n            }\n\n            await this.connect();\n        }\n    }\n\n    setupGracefulShutdown() {\n        process.on(\"SIGINT\", () => {\n            console.log(colors.yellow(\"\\n‚èπÔ∏è  Shutting down...\"));\n            \n            // Stop session cleaner\n            sessionCleaner.stop();\n            \n            this.state.saveMessageStore();\n            console.log(colors.green(\"üíæ Message store saved\"));\n\n            // Log cache stats before exit\n            groupCache.logStats();\n            \n            // Log session stats before exit\n            sessionCleaner.logStats();\n\n            console.log(colors.green(\"üëã Stopped\\n\"));\n            process.exit(0);\n        });\n    }\n}\n\nexport default ConnectionManager;\n\nlib/groupCache.js:\nimport NodeCache from \"node-cache\";\nimport colors from \"@colors/colors/safe.js\";\n\nclass GroupCache {\n    constructor() {\n        this.cache = new NodeCache({\n            stdTTL: 600,\n            checkperiod: 120,\n            useClones: false\n        });\n\n        this.pendingRequests = new Map();\n\n        this.cache.on(\"set\", (key, value) => {\n            console.log(colors.cyan(`üì¶ Cached group metadata: ${key}`));\n        });\n\n        this.cache.on(\"expired\", (key, value) => {\n            console.log(colors.yellow(`‚è∞ Cache expired: ${key}`));\n        });\n\n        this.cache.on(\"del\", (key, value) => {\n            console.log(colors.magenta(`üóëÔ∏è Cache deleted: ${key}`));\n        });\n    }\n\n    get(jid) {\n        return this.cache.get(jid);\n    }\n\n    set(jid, metadata, ttl) {\n        this.cache.set(jid, metadata, ttl);\n    }\n\n    delete(jid) {\n        this.cache.del(jid);\n    }\n\n    clear() {\n        this.cache.flushAll();\n        console.log(colors.green(\"‚ú® Group cache cleared\"));\n    }\n\n    keys() {\n        return this.cache.keys();\n    }\n\n    getStats() {\n        const stats = this.cache.getStats();\n        return {\n            keys: stats.keys,\n            hits: stats.hits,\n            misses: stats.misses,\n            hitRate: stats.hits / (stats.hits + stats.misses) || 0\n        };\n    }\n\n    has(jid) {\n        return this.cache.has(jid);\n    }\n\n    async fetch(sock, jid, forceRefresh = false) {\n        if (this.pendingRequests.has(jid)) {\n            console.log(\n                colors.yellow(`‚è≥ Waiting for pending request: ${jid}`)\n            );\n            return await this.pendingRequests.get(jid);\n        }\n\n        if (!forceRefresh) {\n            const cached = this.get(jid);\n            if (cached) {\n                console.log(colors.green(`‚úÖ Using cached metadata: ${jid}`));\n                return cached;\n            }\n        }\n\n        console.log(colors.cyan(`üîÑ Fetching group metadata: ${jid}`));\n\n        const fetchPromise = (async () => {\n            try {\n                const metadata = await sock.groupMetadata(jid);\n                this.set(jid, metadata);\n                return metadata;\n            } catch (error) {\n                console.error(\n                    colors.red(`‚ùå Failed to fetch metadata for ${jid}:`),\n                    error.message\n                );\n                throw error;\n            } finally {\n                this.pendingRequests.delete(jid);\n            }\n        })();\n\n        this.pendingRequests.set(jid, fetchPromise);\n        return await fetchPromise;\n    }\n\n    getParticipants(jid) {\n        const metadata = this.get(jid);\n        return metadata?.participants || [];\n    }\n\n    getAdmins(jid) {\n        const metadata = this.get(jid);\n        if (!metadata) return [];\n\n        return metadata.participants\n            .filter(p => p.admin === \"admin\" || p.admin === \"superadmin\")\n            .map(p => p.phoneNumber);\n    }\n\n    isAdmin(jid, userJid) {\n        const admins = this.getAdmins(jid);\n        return admins.includes(userJid);\n    }\n\n    getSubject(jid) {\n        const metadata = this.get(jid);\n        return metadata?.subject || \"\";\n    }\n\n    getDesc(jid) {\n        const metadata = this.get(jid);\n        return metadata?.desc || \"\";\n    }\n\n    updateParticipant(jid, participantJid, updates) {\n        const metadata = this.get(jid);\n        if (!metadata) return;\n\n        const participantIndex = metadata.participants.findIndex(\n            p => p.id === participantJid\n        );\n\n        if (participantIndex !== -1) {\n            metadata.participants[participantIndex] = {\n                ...metadata.participants[participantIndex],\n                ...updates\n            };\n            this.set(jid, metadata);\n            console.log(\n                colors.cyan(`üìù Updated participant cache: ${participantJid}`)\n            );\n        }\n    }\n\n    addParticipants(jid, participantJids) {\n        const metadata = this.get(jid);\n        if (!metadata) return;\n\n        participantJids.forEach(participantJid => {\n            const exists = metadata.participants.some(\n                p => p.id === participantJid\n            );\n            if (!exists) {\n                metadata.participants.push({\n                    id: participantJid,\n                    admin: null\n                });\n            }\n        });\n\n        this.set(jid, metadata);\n        console.log(\n            colors.cyan(\n                `‚ûï Added participants to cache: ${participantJids.join(\", \")}`\n            )\n        );\n    }\n\n    removeParticipants(jid, participantJids) {\n        const metadata = this.get(jid);\n        if (!metadata) return;\n\n        metadata.participants = metadata.participants.filter(\n            p => !participantJids.includes(p.id)\n        );\n\n        this.set(jid, metadata);\n        console.log(\n            colors.cyan(\n                `‚ûñ Removed participants from cache: ${participantJids.join(\n                    \", \"\n                )}`\n            )\n        );\n    }\n\n    updateSubject(jid, subject) {\n        const metadata = this.get(jid);\n        if (!metadata) return;\n\n        metadata.subject = subject;\n        this.set(jid, metadata);\n        console.log(colors.cyan(`üìù Updated group subject in cache: ${jid}`));\n    }\n\n    logStats() {\n        const stats = this.getStats();\n        console.log(colors.cyan(\"\\nüìä Cache Statistics:\"));\n        console.log(colors.white(`   Keys: ${stats.keys}`));\n        console.log(colors.white(`   Hits: ${stats.hits}`));\n        console.log(colors.white(`   Misses: ${stats.misses}`));\n        console.log(\n            colors.white(`   Hit Rate: ${(stats.hitRate * 100).toFixed(2)}%\\n`)\n        );\n    }\n}\n\nexport default new GroupCache();\n\nlib/MessageHandler.js:\nimport { jidNormalizedUser } from \"@whiskeysockets/baileys\";\nimport { exec } from \"child_process\";\nimport util from \"util\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport colors from \"@colors/colors/safe.js\";\nimport serialize from \"./serialize.js\";\nimport groupCache from \"./groupCache.js\";\nimport messageLogger from \"./messageLogger.js\";\n\nconst execPromise = util.promisify(exec);\nconst config = await import(\"../config.js\").then(m => m.default);\n\nclass MessageHandler {\n    constructor(state, pluginManager) {\n        this.state = state;\n        this.pluginManager = pluginManager;\n    }\n\n    async handleMessage(sock, m) {\n        if (!m.message) return;\n\n        // Serialize message\n        m = await serialize(m, sock);\n\n        const chat = m.chat.endsWith(\"broadcast\")\n            ? jidNormalizedUser(sock.user.id)\n            : m.chat;\n        const messageId = m.key.id;\n\n        // Log incoming message using messageLogger\n        messageLogger.logIncomingMessage(m, chat);\n\n        // Cache group metadata when message comes from group\n        if (m.isGroup && !groupCache.has(chat)) {\n            groupCache.fetch(sock, chat).catch(err => {\n                console.error(\n                    colors.red(\"Failed to cache group metadata:\"),\n                    err.message\n                );\n            });\n        }\n\n        // Store message (non-group only)\n        if (!m.isGroup && !m.fromMe && !m.isChannel) {\n            this.state.addMessage(messageId, {\n                message: m,\n                from: chat,\n                timestamp: Date.now()\n            });\n        }\n\n        // Filter: only process self messages in groups, all messages in private\n        if (!m.isGroup && !m.fromMe) return;\n        if (m.isGroup && m.key.participant !== jidNormalizedUser(sock.user.lid))\n            return;\n\n        if (!m.text) return;\n\n        // Handle special commands\n        if (await this.handleEval(sock, m)) return;\n        if (await this.handleExec(sock, m)) return;\n\n        // Handle plugin commands\n        await this.handlePluginCommand(sock, m);\n    }\n\n    async handleEval(sock, m) {\n        const text = m.text;\n\n        // Eval with >\n        if (text.startsWith(\">\") && !text.startsWith(\"=>\")) {\n            const code = text.slice(1).trim();\n            if (!code) {\n                await m.reply(\"No code provided\");\n                return true;\n            }\n            console.log(colors.cyan(`üì© eval`));\n            await this.executeEval(sock, m, code, false);\n            return true;\n        }\n\n        // Eval with return (=>)\n        if (text.startsWith(\"=>\")) {\n            const code = text.slice(2).trim();\n            if (!code) {\n                await m.reply(\"No code provided\");\n                return true;\n            }\n            console.log(colors.cyan(`üì© eval-return`));\n            await this.executeEval(sock, m, code, true);\n            return true;\n        }\n\n        return false;\n    }\n\n    async executeEval(sock, m, code, withReturn) {\n        try {\n            const wrappedCode = withReturn ? `return ${code}` : code;\n            const evalFunc = new Function(\n                \"sock\",\n                \"m\",\n                \"plugins\",\n                \"config\",\n                \"fs\",\n                \"path\",\n                \"util\",\n                \"colors\",\n                \"loadPlugins\",\n                \"messageStore\",\n                `return (async () => { ${wrappedCode} })()`\n            );\n            const result = await evalFunc(\n                sock,\n                m,\n                this.state.plugins,\n                config,\n                fs,\n                path,\n                util,\n                colors,\n                () => this.pluginManager.loadPlugins(),\n                this.state.messageStore\n            );\n            const output = util.inspect(result, {\n                depth: null,\n                maxArrayLength: null,\n                maxStringLength: null\n            });\n            await sock.sendMessage(\n                m.chat.endsWith(\"broadcast\")\n                    ? jidNormalizedUser(sock.user.id)\n                    : m.chat,\n                { text: output },\n                { quoted: m }\n            );\n        } catch (error) {\n            await sock.sendMessage(\n                m.chat.endsWith(\"broadcast\")\n                    ? jidNormalizedUser(sock.user.id)\n                    : m.chat,\n                { text: error.message },\n                { quoted: m }\n            );\n        }\n    }\n\n    async handleExec(sock, m) {\n        const text = m.text;\n        if (!text.startsWith(\"$\")) return false;\n\n        const cmd = text.slice(1).trim();\n        if (!cmd) {\n            await m.reply(\"No command provided\");\n            return true;\n        }\n\n        console.log(colors.cyan(`üì© exec`));\n        try {\n            await m.reply(`‚è≥ Executing: ${cmd}`);\n            const { stdout, stderr } = await execPromise(cmd);\n            let output = stdout || \"\";\n            if (stderr) output += `Error:\\n${stderr}`;\n            if (!output) output = \"‚úÖ Executed (no output)\";\n            await m.reply(output);\n        } catch (error) {\n            await m.reply(error.message);\n        }\n        return true;\n    }\n\n    async handlePluginCommand(sock, m) {\n        const prefixes = config.PREFIX || [\".\"];\n        const prefix = prefixes.find(p => m.text.startsWith(p));\n        if (!prefix) return;\n\n        const args = m.text.slice(prefix.length).trim().split(/ +/);\n        const command = args.shift()?.toLowerCase();\n        if (!command) return;\n\n        console.log(colors.cyan(`üì© ${command}`));\n\n        if (this.state.plugins.has(command)) {\n            // Try to get file buffer from quoted or current message\n            let fileBuffer = null;\n            if (m.quoted && m.quoted.isMedia) {\n                fileBuffer = await m.quoted.download();\n            } else if (m.isMedia) {\n                fileBuffer = await m.download();\n            }\n\n            const context = {\n                sock,\n                chat: m.chat,\n                from: m.chat, // Alias\n                args,\n                text: args.join(\" \"),\n                m,\n                fileBuffer,\n                isGroup: m.isGroup,\n                sender: m.sender,\n                groupCache, // Add groupCache to context\n                reply: async (content, options) =>\n                    await m.reply(content, options)\n            };\n\n            await this.pluginManager.executePlugin(command, context);\n        }\n    }\n}\n\nexport default MessageHandler;\n\nlib/messageLogger.js:\nimport colors from \"@colors/colors/safe.js\";\nimport groupCache from \"./groupCache.js\";\n\nclass MessageLogger {\n    constructor() {\n        this.separator = colors.gray(\"‚ïê\".repeat(80));\n        this.thinLine = colors.gray(\"‚îÄ\".repeat(80));\n    }\n\n    /**\n     * Log detailed information about incoming message\n     * @param {Object} m - Serialized message object\n     * @param {string} chat - Chat ID\n     */\n    logIncomingMessage(m, chat) {\n        console.log(this.separator);\n        this.logHeader(m);\n        this.logMessageInfo(m, chat);\n        this.logMessageContent(m);\n        this.logTechnicalDetails(m);\n        this.logFlags(m);\n        console.log(this.separator);\n        console.log(\"\"); // Empty line for readability\n    }\n\n    /**\n     * Log header with timestamp\n     */\n    logHeader(m) {\n        const timestamp = new Date().toLocaleString(\"id-ID\", {\n            timeZone: \"Asia/Jakarta\"\n        });\n        console.log(\n            colors.cyan.bold(`üì® INCOMING MESSAGE`) +\n                colors.gray(` | ${timestamp}`)\n        );\n        console.log(this.thinLine);\n    }\n\n    /**\n     * Log message direction, type and sender info\n     */\n    logMessageInfo(m, chat) {\n        // Message Type & Direction\n        const messageDirection = m.fromMe ? \"OUTGOING (Self)\" : \"INCOMING\";\n        const chatType = m.isGroup\n            ? \"GROUP CHAT\"\n            : m.isChannel\n            ? \"FROM CHANNEL\"\n            : \"PRIVATE CHAT\";\n        console.log(\n            colors.white(`üìç Direction: `) + colors.yellow(messageDirection)\n        );\n        console.log(colors.white(`üí¨ Chat Type: `) + colors.blue(chatType));\n\n        // Sender Info\n        const senderName = m.isChannel\n            ? \"(ADMIN CHANNEL)\"\n            : m.pushName || \"Unknown\";\n        const senderNumber = m.isChannel\n            ? \"ADMIN CHANNEL\"\n            : m.sender?.split(\"@\")[0] || \"Unknown\";\n        console.log(\n            colors.white(`üë§ Sender: `) +\n                colors.green(senderName) +\n                colors.gray(` (${senderNumber})`)\n        );\n\n        // Group Info (if applicable)\n        if (m.isGroup) {\n            const groupName = groupCache.has(chat)\n                ? groupCache.get(chat)?.subject || \"Unknown Group\"\n                : \"Loading...\";\n            const groupId = chat.split(\"@\")[0];\n            console.log(\n                colors.white(`üë• Group: `) +\n                    colors.magenta(groupName) +\n                    colors.gray(` (${groupId})`)\n            );\n        }\n        if (m.isChannel) {\n            const channelName = m.channelName;\n            const channelId = m.chat.split(\"@\")[0];\n            console.log(\n                colors.white(`üì± Channel: `) +\n                    colors.magenta(channelName) +\n                    colors.gray(` (${channelId})`)\n            );\n        }\n\n        // Message Type Detection\n        const messageType = this.getDetailedMessageType(m);\n        console.log(\n            colors.white(`üì¶ Message Type: `) + colors.cyan(messageType)\n        );\n\n        // Quoted Message Info\n        if (m.quoted) {\n            const quotedType = this.getDetailedMessageType(m.quoted);\n            const quotedSender = m.quoted.sender?.split(\"@\")[0] || \"Unknown\";\n            console.log(\n                colors.white(`‚Ü©Ô∏è  Quoted: `) +\n                    colors.yellow(quotedType) +\n                    colors.gray(` from @${quotedSender}`)\n            );\n        }\n\n        // Media Info\n        if (m.isMedia) {\n            const mediaInfo = this.getMediaInfo(m);\n            console.log(\n                colors.white(`üé¨ Media Info: `) + colors.yellow(mediaInfo)\n            );\n        }\n    }\n\n    /**\n     * Log message content\n     */\n    logMessageContent(m) {\n        console.log(this.thinLine);\n        if (m.text) {\n            const maxLength = 200;\n            const textPreview =\n                m.text.length > maxLength\n                    ? m.text.substring(0, maxLength) + \"...\"\n                    : m.text;\n            console.log(\n                colors.white(`üìù Content:\\n`) + colors.white(textPreview)\n            );\n        } else if (m.message?.conversation) {\n            console.log(\n                colors.white(`üìù Content:\\n`) +\n                    colors.white(m.message.conversation)\n            );\n        } else {\n            console.log(colors.gray(`üìù Content: (No text content)`));\n        }\n    }\n\n    /**\n     * Log technical details (ID, timestamp)\n     */\n    logTechnicalDetails(m) {\n        console.log(this.thinLine);\n        console.log(colors.white(`üîë Message ID: `) + colors.gray(m.key.id));\n        console.log(\n            colors.white(`‚è±Ô∏è  Timestamp: `) +\n                colors.gray(\n                    new Date(m.messageTimestamp * 1000).toLocaleString(\n                        \"id-ID\",\n                        {\n                            timeZone: \"Asia/Jakarta\"\n                        }\n                    )\n                )\n        );\n    }\n\n    /**\n     * Log special flags\n     */\n    logFlags(m) {\n        const flags = [];\n        if (m.isGroup) flags.push(\"GROUP\");\n        if (m.fromMe) flags.push(\"SELF\");\n        if (m.quoted) flags.push(\"REPLY\");\n        if (m.isMedia) flags.push(\"MEDIA\");\n        if (m.mentions?.length > 0)\n            flags.push(`MENTIONS(${m.mentions.length})`);\n\n        if (flags.length > 0) {\n            console.log(\n                colors.white(`üè∑Ô∏è  Flags: `) + colors.cyan(flags.join(\" | \"))\n            );\n        }\n    }\n\n    /**\n     * Get detailed message type description\n     * @param {Object} m - Message object\n     * @returns {string} Message type description\n     */\n    getDetailedMessageType(m) {\n        const msg = m.message || {};\n\n        if (msg.conversation) return \"üìÑ Text Message\";\n        if (msg.extendedTextMessage)\n            return \"üìÑ Extended Text (with link/quote)\";\n        if (msg.imageMessage)\n            return (\n                \"üñºÔ∏è  Image\" +\n                (msg.imageMessage.caption ? \" (with caption)\" : \"\")\n            );\n        if (msg.videoMessage)\n            return (\n                \"üé• Video\" + (msg.videoMessage.caption ? \" (with caption)\" : \"\")\n            );\n        if (msg.audioMessage) {\n            if (msg.audioMessage.ptt) return \"üé§ Voice Note\";\n            return \"üéµ Audio File\";\n        }\n        if (msg.documentMessage) {\n            const fileName = msg.documentMessage.fileName || \"Unknown\";\n            const fileType = fileName.split(\".\").pop();\n            return `üìÑ Document (.${fileType})`;\n        }\n        if (msg.stickerMessage) return \"üé≠ Sticker\";\n        if (msg.contactMessage) return \"üë§ Contact Card\";\n        if (msg.locationMessage) return \"üìç Location\";\n        if (msg.liveLocationMessage) return \"üìç Live Location\";\n        if (msg.pollCreationMessage) return \"üìä Poll\";\n        if (msg.reactionMessage) return \"‚ù§Ô∏è Reaction\";\n        if (msg.viewOnceMessage) return \"üëÅÔ∏è View Once Message\";\n        if (msg.buttonsMessage) return \"üîò Buttons Message\";\n        if (msg.listMessage) return \"üìã List Message\";\n        if (msg.templateMessage) return \"üìù Template Message\";\n        if (msg.protocolMessage) {\n            const type = msg.protocolMessage.type;\n            if (type === 0) return \"üîÑ Revoke Message\";\n            if (type === 14) return \"‚úèÔ∏è Edit Message\";\n            return `‚öôÔ∏è Protocol Message (${type})`;\n        }\n\n        return \"‚ùì Unknown Type\";\n    }\n\n    /**\n     * Get media information\n     * @param {Object} m - Message object\n     * @returns {string} Media information string\n     */\n    getMediaInfo(m) {\n        const msg = m.message || {};\n        const info = [];\n\n        if (msg.imageMessage) {\n            const img = msg.imageMessage;\n            info.push(`Size: ${this.formatBytes(img.fileLength || 0)}`);\n            if (img.width && img.height)\n                info.push(`Res: ${img.width}x${img.height}`);\n            if (img.mimetype) info.push(`Type: ${img.mimetype}`);\n        } else if (msg.videoMessage) {\n            const vid = msg.videoMessage;\n            info.push(`Size: ${this.formatBytes(vid.fileLength || 0)}`);\n            if (vid.seconds) info.push(`Duration: ${vid.seconds}s`);\n            if (vid.mimetype) info.push(`Type: ${vid.mimetype}`);\n        } else if (msg.audioMessage) {\n            const aud = msg.audioMessage;\n            info.push(`Size: ${this.formatBytes(aud.fileLength || 0)}`);\n            if (aud.seconds) info.push(`Duration: ${aud.seconds}s`);\n            if (aud.ptt) info.push(`Voice Note`);\n        } else if (msg.documentMessage) {\n            const doc = msg.documentMessage;\n            info.push(`Size: ${this.formatBytes(doc.fileLength || 0)}`);\n            if (doc.fileName) info.push(`Name: ${doc.fileName}`);\n            if (doc.mimetype) info.push(`Type: ${doc.mimetype}`);\n        } else if (msg.stickerMessage) {\n            const sticker = msg.stickerMessage;\n            info.push(`Size: ${this.formatBytes(sticker.fileLength || 0)}`);\n            if (sticker.isAnimated) info.push(`Animated`);\n        }\n\n        return info.join(\" | \") || \"No details available\";\n    }\n\n    /**\n     * Format bytes to human readable format\n     * @param {number} bytes - Bytes to format\n     * @returns {string} Formatted string\n     */\n    formatBytes(bytes) {\n        if (bytes === 0) return \"0 B\";\n        const k = 1024;\n        const sizes = [\"B\", \"KB\", \"MB\", \"GB\"];\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + \" \" + sizes[i];\n    }\n}\n\n// Export singleton instance\nexport default new MessageLogger();\n\n\nlib/PluginManager.js:\nimport fs from \"fs\";\nimport path from \"path\";\nimport colors from \"@colors/colors/safe.js\";\nimport { fileURLToPath } from \"url\";\nimport { dirname } from \"path\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\nconst PLUGIN_DIR = path.join(__dirname, \"..\", \"plugins\");\n\nclass PluginManager {\n    constructor(state) {\n        this.state = state;\n    }\n\n    async loadPlugins() {\n        try {\n            if (!fs.existsSync(PLUGIN_DIR)) {\n                fs.mkdirSync(PLUGIN_DIR, { recursive: true });\n            }\n\n            this.state.plugins.clear();\n            const files = fs\n                .readdirSync(PLUGIN_DIR)\n                .filter(f => f.endsWith(\".js\"));\n\n            for (const file of files) {\n                await this.loadPlugin(file);\n            }\n\n            console.log(\n                colors.cyan(`üîå ${this.state.plugins.size} plugins loaded`)\n            );\n        } catch (error) {\n            console.error(\n                colors.red(\"‚ùå Plugin loading error:\"),\n                error.message\n            );\n        }\n    }\n\n    async loadPlugin(file) {\n        try {\n            const pluginPath = path.join(PLUGIN_DIR, file);\n            const pluginUrl = `file://${pluginPath}?update=${Date.now()}`;\n            const module = await import(pluginUrl);\n            const execute = module.default;\n\n            if (typeof execute === \"function\") {\n                const command = path.basename(file, \".js\");\n                this.state.plugins.set(command, execute);\n            }\n        } catch (error) {\n            console.error(colors.red(`‚ùå Plugin ${file}:`), error.message);\n        }\n    }\n\n    async executePlugin(command, context) {\n        const execute = this.state.plugins.get(command);\n        if (!execute) return false;\n\n        try {\n            await context.m.react(\"‚è≥\");\n        } catch (e) {\n            console.error(colors.red(\"‚ùå Failed to send reaction:\"), e.message);\n        }\n\n        try {\n            await execute(context);\n            console.log(colors.green(`‚úÖ ${command} executed`));\n            return true;\n        } catch (error) {\n            console.error(colors.red(`‚ùå Plugin error:`), error);\n            await context.m.reply(`‚ùå Plugin error: ${error.message}`);\n            return false;\n        } finally {\n            try {\n                await context.m.react(\"\");\n            } catch (e) {\n                console.error(\n                    colors.red(\"‚ùå Failed to remove reaction:\"),\n                    e.message\n                );\n            }\n        }\n    }\n}\n\nexport default PluginManager;\n\nlib/serialize.js:\nimport {\n    jidNormalizedUser,\n    downloadMediaMessage\n} from \"@whiskeysockets/baileys\";\nimport Pino from \"pino\";\nconst config = (await import(\"../config.js\")).default;\n\nexport default async function serialize(m, sock) {\n    if (!m) return m;\n\n    m.isGroup = m.key.remoteJid.endsWith(\"@g.us\");\n    m.isStatus = m.key.remoteJid.endsWith(\"@broadcast\");\n    m.isChannel = m.key.remoteJid.endsWith(\"@newsletter\");\n    m.chat = m.key.remoteJid;\n    m.from = m.chat;\n    if (m.isChannel)\n        m.channelName = (\n            await sock.newsletterMetadata(\"jid\", m.chat)\n        ).thread_metadata.name.text;\n\n    let getJid = m.isGroup\n        ? await sock.getJidParticipants(m.chat, m.key.participant)\n        : m.chat;\n\n    m.key = {\n        remoteJid: m.key.remoteJid,\n        fromMe: !m.isGroup\n            ? m.key.fromMe\n            : m.isStatus\n            ? m.key.fromMe\n            : jidNormalizedUser(sock.user.id) == getJid\n            ? true\n            : false,\n        id: m.key.id,\n        participant: m.isGroup\n            ? m.key.participant\n            : m.isStatus\n            ? m.key.participant\n            : m.chat,\n        participantJid: m.isStatus ? m.key.participant : getJid\n    };\n\n    m.sender = jidNormalizedUser(\n        m.key.fromMe\n            ? sock.user.id\n            : m.isGroup\n            ? getJid\n            : m.isStatus\n            ? m.key.participant\n            : m.chat\n    );\n    m.fromMe = m.key.fromMe;\n\n    const type = Object.keys(m.message || {})[0];\n    m.type = type;\n\n    const msg = m.message?.[type] || {};\n    m.msg = msg;\n\n    m.text =\n        m.message?.conversation ||\n        msg?.text ||\n        msg?.caption ||\n        msg?.contentText ||\n        msg?.selectedDisplayText ||\n        msg?.title ||\n        \"\";\n\n    if (msg?.contextInfo?.quotedMessage) {\n        const quoted = msg.contextInfo.quotedMessage;\n        const quotedType = Object.keys(quoted)[0];\n        const quotedMsg = quoted[quotedType];\n        let getJidQuoted = m.chat.includes(\"@g.us\")\n            ? await sock.getJidParticipants(m.chat, msg.contextInfo.participant)\n            : m.chat;\n\n        m.quoted = {\n            key: {\n                remoteJid: m.chat,\n                fromMe:\n                    msg.contextInfo.participant ===\n                    jidNormalizedUser(sock.user.id),\n                id: msg.contextInfo.stanzaId,\n                participant:\n                    msg.contextInfo.participant ===\n                        jidNormalizedUser(sock.user.id) &&\n                    m.chat.includes(\"@g.us\")\n                        ? await sock.getLidParticipants(\n                              m.chat,\n                              msg.contextInfo.participant\n                          )\n                        : msg.contextInfo.participant,\n                participantJid:\n                    msg.contextInfo.participant ===\n                        jidNormalizedUser(sock.user.id) &&\n                    m.chat.includes(\"@g.us\")\n                        ? msg.contextInfo.participant\n                        : getJidQuoted\n            },\n            message: quoted,\n            type: quotedType,\n            msg: quotedMsg,\n            text:\n                quoted.conversation ||\n                quotedMsg?.text ||\n                quotedMsg?.caption ||\n                quotedMsg?.contentText ||\n                \"\",\n            sender:\n                msg.contextInfo.participant ===\n                    jidNormalizedUser(sock.user.id) && m.chat.includes(\"@g.us\")\n                    ? msg.contextInfo.participant\n                    : getJidQuoted,\n            isGroup: m.chat.includes(\"@g.us\"),\n\n            isMedia: !!(\n                quotedMsg?.mimetype ||\n                quotedType === \"imageMessage\" ||\n                quotedType === \"videoMessage\" ||\n                quotedType === \"audioMessage\" ||\n                quotedType === \"stickerMessage\" ||\n                quotedType === \"documentMessage\"\n            ),\n\n            download: async () => {\n                try {\n                    return await downloadMediaMessage(\n                        { message: quoted, key: m.quoted.key },\n                        \"buffer\",\n                        {},\n                        { logger: Pino({ level: \"silent\" }) }\n                    );\n                } catch (e) {\n                    console.error(\n                        \"Failed to download quoted media:\",\n                        e.message\n                    );\n                    return null;\n                }\n            }\n        };\n    }\n\n    m.download = async () => {\n        try {\n            return await downloadMediaMessage(\n                m,\n                \"buffer\",\n                {},\n                { logger: Pino({ level: \"silent\" }) }\n            );\n        } catch (e) {\n            console.error(\"Failed to download media:\", e.message);\n            return null;\n        }\n    };\n\n    m.reply = async (content, options = {}) => {\n        const message =\n            typeof content === \"string\"\n                ? {\n                      text: content,\n                      contextInfo: {\n                          externalAdReply: {\n                              title: `${config.BOT_NAME} - SELFBOT`,\n                              body: `Owned by ${config.OWNER_NAME}`,\n                              thumbnailUrl: await sock.profilePictureUrl(\n                                  m.sender,\n                                  \"image\"\n                              ),\n                              mediaType: 2,\n                              previewType: \"PHOTO\",\n                              mediaUrl: \"https://github.com/ikyyyofc/selfbot\",\n                              showAdAttribution: false,\n                              renderLargerThumbnail: false\n                          }\n                      }\n                  }\n                : content;\n        return await sock.sendMessage(m.chat, message, {\n            quoted: m,\n            ...options\n        });\n    };\n\n    m.react = async emoji => {\n        return await sock.sendMessage(m.chat, {\n            react: { text: emoji, key: m.key }\n        });\n    };\n\n    m.mentions = msg?.contextInfo?.mentionedJid || [];\n\n    m.isMedia = !!(\n        msg?.mimetype ||\n        m.type === \"imageMessage\" ||\n        m.type === \"videoMessage\" ||\n        m.type === \"audioMessage\" ||\n        m.type === \"stickerMessage\" ||\n        m.type === \"documentMessage\"\n    );\n\n    m.timestamp = m.messageTimestamp;\n    m.pushName = m.pushName || m.sender.split(\"@\")[0];\n\n    return m;\n}\n\n\nlib/SessionCleaner.js:\nimport fs from \"fs\";\nimport path from \"path\";\nimport colors from \"@colors/colors/safe.js\";\n\nconst config = await import(\"../config.js\").then(m => m.default);\n\nclass SessionCleaner {\n    constructor(sessionDir = config.SESSION) {\n        this.sessionDir = sessionDir;\n        this.cleanupInterval = null;\n        \n        // Konfigurasi cleanup\n        this.config = {\n            // Interval cleanup (default: setiap 6 jam)\n            intervalHours: config.SESSION_CLEANUP_INTERVAL || 6,\n            \n            // Ukuran maksimal session folder (dalam MB)\n            maxSizeMB: config.SESSION_MAX_SIZE_MB || 500,\n            \n            // HANYA file ini yang TIDAK akan dihapus (whitelist)\n            protectedFiles: [\n                \"creds.json\",                       // Kredensial akun (WAJIB)\n                \"app-state-sync-key-*.json\",       // Encryption keys (WAJIB)\n                \"message_store.json\"                // Message store untuk anti-delete\n            ]\n        };\n    }\n\n    /**\n     * Mulai auto cleanup dengan interval tertentu\n     */\n    start() {\n        if (this.cleanupInterval) {\n            console.log(colors.yellow(\"‚ö†Ô∏è  Session cleaner already running\"));\n            return;\n        }\n\n        console.log(\n            colors.cyan(\n                `üßπ Session cleaner started (every ${this.config.intervalHours}h)`\n            )\n        );\n\n        // Cleanup pertama kali saat start\n        this.cleanup();\n\n        // Set interval untuk cleanup berkala\n        const intervalMs = this.config.intervalHours * 60 * 60 * 1000;\n        this.cleanupInterval = setInterval(() => {\n            this.cleanup();\n        }, intervalMs);\n    }\n\n    /**\n     * Stop auto cleanup\n     */\n    stop() {\n        if (this.cleanupInterval) {\n            clearInterval(this.cleanupInterval);\n            this.cleanupInterval = null;\n            console.log(colors.yellow(\"üõë Session cleaner stopped\"));\n        }\n    }\n\n    /**\n     * Cleanup session folder - HAPUS SEMUA kecuali yang protected\n     */\n    async cleanup() {\n        try {\n            console.log(colors.cyan(\"\\nüßπ Starting aggressive session cleanup...\"));\n\n            if (!fs.existsSync(this.sessionDir)) {\n                console.log(colors.yellow(\"‚ö†Ô∏è  Session directory not found\"));\n                return;\n            }\n\n            const beforeSize = this.getCleanableSize(this.sessionDir);\n            const beforeSizeMB = (beforeSize / 1024 / 1024).toFixed(2);\n\n            console.log(\n                colors.cyan(`üìä Current cleanable size: ${beforeSizeMB} MB`)\n            );\n\n            // Cek apakah perlu cleanup berdasarkan ukuran\n            if (beforeSize / 1024 / 1024 < this.config.maxSizeMB) {\n                console.log(\n                    colors.green(\n                        `‚úÖ Cleanable size below limit (${this.config.maxSizeMB} MB), cleanup skipped`\n                    )\n                );\n                return;\n            }\n\n            let deletedCount = 0;\n            let deletedSize = 0;\n            const files = fs.readdirSync(this.sessionDir);\n\n            // Loop semua file dan hapus yang TIDAK protected\n            for (const file of files) {\n                const filePath = path.join(this.sessionDir, file);\n                \n                try {\n                    const stats = fs.statSync(filePath);\n                    \n                    // Skip direktori\n                    if (stats.isDirectory()) continue;\n                    \n                    // Skip file yang protected\n                    if (this.isProtected(file)) {\n                        console.log(colors.green(`‚úÖ Protected: ${file}`));\n                        continue;\n                    }\n                    \n                    // Hapus file\n                    deletedSize += stats.size;\n                    fs.unlinkSync(filePath);\n                    deletedCount++;\n                    console.log(colors.red(`üóëÔ∏è  Deleted: ${file}`));\n                    \n                } catch (error) {\n                    console.error(\n                        colors.red(`‚ùå Error deleting ${file}:`),\n                        error.message\n                    );\n                }\n            }\n\n            const afterSize = this.getCleanableSize(this.sessionDir);\n            const afterSizeMB = (afterSize / 1024 / 1024).toFixed(2);\n            const deletedSizeMB = (deletedSize / 1024 / 1024).toFixed(2);\n\n            console.log(\n                colors.green(\n                    `‚úÖ Cleanup completed: ${deletedCount} files deleted (${deletedSizeMB} MB freed)`\n                )\n            );\n            console.log(\n                colors.cyan(`üìä New cleanable size: ${afterSizeMB} MB\\n`)\n            );\n        } catch (error) {\n            console.error(\n                colors.red(\"‚ùå Session cleanup error:\"),\n                error.message\n            );\n        }\n    }\n\n    /**\n     * Cek apakah file dilindungi (tidak boleh dihapus)\n     */\n    isProtected(filename) {\n        for (const pattern of this.config.protectedFiles) {\n            const regex = this.patternToRegex(pattern);\n            if (regex.test(filename)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Convert wildcard pattern ke regex\n     */\n    patternToRegex(pattern) {\n        const escaped = pattern\n            .replace(/[.+?^${}()|[\\]\\\\]/g, \"\\\\$&\")\n            .replace(/\\*/g, \".*\");\n        return new RegExp(`^${escaped}$`);\n    }\n\n    /**\n     * Hitung ukuran file yang bisa dihapus (non-protected)\n     */\n    getCleanableSize(dirPath) {\n        let totalSize = 0;\n\n        try {\n            const files = fs.readdirSync(dirPath);\n\n            for (const file of files) {\n                const filePath = path.join(dirPath, file);\n                const stats = fs.statSync(filePath);\n\n                if (stats.isFile()) {\n                    // Hitung hanya file yang TIDAK protected\n                    if (!this.isProtected(file)) {\n                        totalSize += stats.size;\n                    }\n                } else if (stats.isDirectory()) {\n                    totalSize += this.getCleanableSize(filePath);\n                }\n            }\n        } catch (error) {\n            console.error(\n                colors.red(\"‚ùå Error calculating cleanable size:\"),\n                error.message\n            );\n        }\n\n        return totalSize;\n    }\n\n    /**\n     * Hitung ukuran folder\n     */\n    getFolderSize(dirPath) {\n        let totalSize = 0;\n\n        try {\n            const files = fs.readdirSync(dirPath);\n\n            for (const file of files) {\n                const filePath = path.join(dirPath, file);\n                const stats = fs.statSync(filePath);\n\n                if (stats.isFile()) {\n                    totalSize += stats.size;\n                } else if (stats.isDirectory()) {\n                    totalSize += this.getFolderSize(filePath);\n                }\n            }\n        } catch (error) {\n            console.error(\n                colors.red(\"‚ùå Error calculating folder size:\"),\n                error.message\n            );\n        }\n\n        return totalSize;\n    }\n\n    /**\n     * Manual cleanup (bisa dipanggil via command)\n     */\n    async manualCleanup() {\n        console.log(colors.cyan(\"üßπ Manual cleanup triggered...\"));\n        \n        // Untuk manual cleanup, langsung cleanup tanpa cek ukuran\n        const tempMaxSize = this.config.maxSizeMB;\n        this.config.maxSizeMB = 0; // Set ke 0 supaya pasti cleanup\n        \n        await this.cleanup();\n        \n        this.config.maxSizeMB = tempMaxSize; // Restore\n    }\n\n    /**\n     * Get session statistics\n     */\n    getStats() {\n        try {\n            const totalSize = this.getFolderSize(this.sessionDir);\n            const cleanableSize = this.getCleanableSize(this.sessionDir);\n            const files = fs.readdirSync(this.sessionDir);\n            \n            const fileList = files.filter(f => {\n                const stats = fs.statSync(path.join(this.sessionDir, f));\n                return stats.isFile();\n            });\n            \n            const protectedCount = fileList.filter(f => this.isProtected(f)).length;\n            const unprotectedCount = fileList.length - protectedCount;\n\n            return {\n                totalSizeMB: (totalSize / 1024 / 1024).toFixed(2),\n                totalSizeBytes: totalSize,\n                cleanableSizeMB: (cleanableSize / 1024 / 1024).toFixed(2),\n                cleanableSizeBytes: cleanableSize,\n                fileCount: fileList.length,\n                protectedCount,\n                unprotectedCount,\n                maxSizeMB: this.config.maxSizeMB,\n                isOverLimit: cleanableSize / 1024 / 1024 > this.config.maxSizeMB\n            };\n        } catch (error) {\n            console.error(\n                colors.red(\"‚ùå Error getting stats:\"),\n                error.message\n            );\n            return null;\n        }\n    }\n\n    /**\n     * Log current statistics\n     */\n    logStats() {\n        const stats = this.getStats();\n        if (!stats) return;\n\n        console.log(colors.cyan(\"\\nüìä Session Statistics:\"));\n        console.log(colors.cyan(`   Total Files: ${stats.fileCount}`));\n        console.log(colors.green(`   Protected: ${stats.protectedCount}`));\n        console.log(colors.yellow(`   Cleanable: ${stats.unprotectedCount}`));\n        console.log(colors.cyan(`   Total Size: ${stats.totalSizeMB} MB`));\n        console.log(colors.cyan(`   Cleanable Size: ${stats.cleanableSizeMB} MB`));\n        console.log(colors.cyan(`   Limit: ${stats.maxSizeMB} MB`));\n\n        if (stats.isOverLimit) {\n            console.log(\n                colors.red(`   ‚ö†Ô∏è  Over limit! Cleanup will run automatically`)\n            );\n        } else {\n            console.log(colors.green(`   ‚úÖ Within limit`));\n        }\n        console.log();\n    }\n\n    /**\n     * List protected files\n     */\n    listProtectedFiles() {\n        try {\n            const files = fs.readdirSync(this.sessionDir);\n            const protectedFiles = files.filter(f => {\n                const stats = fs.statSync(path.join(this.sessionDir, f));\n                return stats.isFile() && this.isProtected(f);\n            });\n\n            console.log(colors.cyan(\"\\nüîí Protected Files:\"));\n            protectedFiles.forEach(f => {\n                const size = fs.statSync(path.join(this.sessionDir, f)).size;\n                const sizeMB = (size / 1024 / 1024).toFixed(2);\n                console.log(colors.green(`   ‚úÖ ${f} (${sizeMB} MB)`));\n            });\n            console.log();\n\n            return protectedFiles;\n        } catch (error) {\n            console.error(\n                colors.red(\"‚ùå Error listing protected files:\"),\n                error.message\n            );\n            return [];\n        }\n    }\n\n    /**\n     * List cleanable files (yang akan dihapus)\n     */\n    listCleanableFiles() {\n        try {\n            const files = fs.readdirSync(this.sessionDir);\n            const cleanableFiles = files.filter(f => {\n                const stats = fs.statSync(path.join(this.sessionDir, f));\n                return stats.isFile() && !this.isProtected(f);\n            });\n\n            console.log(colors.cyan(\"\\nüóëÔ∏è  Cleanable Files:\"));\n            cleanableFiles.forEach(f => {\n                const size = fs.statSync(path.join(this.sessionDir, f)).size;\n                const sizeMB = (size / 1024 / 1024).toFixed(2);\n                console.log(colors.yellow(`   üî∏ ${f} (${sizeMB} MB)`));\n            });\n            console.log();\n\n            return cleanableFiles;\n        } catch (error) {\n            console.error(\n                colors.red(\"‚ùå Error listing cleanable files:\"),\n                error.message\n            );\n            return [];\n        }\n    }\n}\n\n// Create singleton instance\nconst sessionCleaner = new SessionCleaner();\n\nexport default sessionCleaner;\n\nlib/socket.js:\nimport {\n    downloadMediaMessage,\n    generateWAMessageFromContent,\n    proto\n} from \"@whiskeysockets/baileys\";\nimport Pino from \"pino\";\nimport groupCache from \"./groupCache.js\";\n\nexport async function extendSocket(sock) {\n    sock.getGroupMetadata = async (jid, forceRefresh = false) => {\n        if (!jid.endsWith(\"@g.us\")) return \"Only for Group\";\n        try {\n            // Check cache first\n            const cachedData = groupCache.get(jid);\n\n            if (forceRefresh || !cachedData) {\n                return await groupCache.fetch(sock, jid, forceRefresh);\n            }\n\n            return cachedData;\n        } catch (e) {\n            console.error(\"Failed to get group metadata:\", e.message);\n            return null;\n        }\n    };\n\n    sock.getGroupParticipants = async (jid, forceRefresh = false) => {\n        if (!jid.endsWith(\"@g.us\")) return \"Only for Group\";\n        try {\n            // Check cache first\n            const cachedParticipants = groupCache.getParticipants(jid);\n\n            if (\n                forceRefresh ||\n                !cachedParticipants ||\n                cachedParticipants.length === 0\n            ) {\n                const metadata = await groupCache.fetch(\n                    sock,\n                    jid,\n                    forceRefresh\n                );\n                return metadata.participants;\n            }\n\n            return cachedParticipants;\n        } catch (e) {\n            console.error(\"Failed to get group participants:\", e.message);\n            return [];\n        }\n    };\n\n    sock.getJidParticipants = async (jid, id, forceRefresh = false) => {\n        if (!jid.endsWith(\"@g.us\")) return \"Only for Group\";\n        try {\n            // Check cache first\n            let participants = groupCache.getParticipants(jid);\n\n            if (forceRefresh || !participants || participants.length === 0) {\n                const metadata = await groupCache.fetch(\n                    sock,\n                    jid,\n                    forceRefresh\n                );\n                participants = metadata.participants;\n            }\n\n            const participant = participants.filter(v => v.id === id)[0];\n            return participant?.phoneNumber || null;\n        } catch (e) {\n            console.error(\"Failed to get participant JID:\", e.message);\n            return null;\n        }\n    };\n\n    sock.getLidParticipants = async (jid, id, forceRefresh = false) => {\n        if (!jid.endsWith(\"@g.us\")) return \"Only for Group\";\n        try {\n            // Check cache first\n            let participants = groupCache.getParticipants(jid);\n\n            if (forceRefresh || !participants || participants.length === 0) {\n                const metadata = await groupCache.fetch(\n                    sock,\n                    jid,\n                    forceRefresh\n                );\n                participants = metadata.participants;\n            }\n\n            const participant = participants.filter(\n                v => v.phoneNumber === id\n            )[0];\n            return participant?.id || null;\n        } catch (e) {\n            console.error(\"Failed to get participant LID:\", e.message);\n            return null;\n        }\n    };\n\n    sock.getGroupAdmins = async (jid, forceRefresh = false) => {\n        if (!jid.endsWith(\"@g.us\")) return \"Only for Group\";\n        try {\n            const cachedAdmins = groupCache.getAdmins(jid);\n\n            if (forceRefresh || !cachedAdmins || cachedAdmins.length === 0) {\n                await groupCache.fetch(sock, jid, forceRefresh);\n                return groupCache.getAdmins(jid);\n            }\n\n            return cachedAdmins;\n        } catch (e) {\n            console.error(\"Failed to get group admins:\", e.message);\n            return [];\n        }\n    };\n\n    sock.isGroupAdmin = async (jid, userJid, forceRefresh = false) => {\n        if (!jid.endsWith(\"@g.us\")) return \"Only for Group\";\n        try {\n            const cachedData = groupCache.get(jid);\n\n            if (forceRefresh || !cachedData) {\n                await groupCache.fetch(sock, jid, forceRefresh);\n            }\n\n            return groupCache.isAdmin(jid, userJid);\n        } catch (e) {\n            console.error(\"Failed to check admin status:\", e.message);\n            return false;\n        }\n    };\n\n    sock.groupAdd = async (jid, participants) => {\n        if (!jid.endsWith(\"@g.us\")) return \"Only for Group\";\n        try {\n            let cachedData = groupCache.get(jid);\n            if (!cachedData) {\n                cachedData = await groupCache.fetch(sock, jid);\n            }\n\n            groupCache.addParticipants(jid, participants);\n\n            const result = await sock.groupParticipantsUpdate(\n                jid,\n                participants,\n                \"add\"\n            );\n\n            await groupCache.fetch(sock, jid, true);\n            return result;\n        } catch (e) {\n            console.error(\"Failed to add participants:\", e.message);\n\n            await groupCache.fetch(sock, jid, true);\n            throw e;\n        }\n    };\n\n    sock.groupRemove = async (jid, participants) => {\n        if (!jid.endsWith(\"@g.us\")) return \"Only for Group\";\n        try {\n            let cachedData = groupCache.get(jid);\n            if (!cachedData) {\n                cachedData = await groupCache.fetch(sock, jid);\n            }\n\n            groupCache.removeParticipants(jid, participants);\n\n            const result = await sock.groupParticipantsUpdate(\n                jid,\n                participants,\n                \"remove\"\n            );\n\n            await groupCache.fetch(sock, jid, true);\n            return result;\n        } catch (e) {\n            console.error(\"Failed to remove participants:\", e.message);\n            await groupCache.fetch(sock, jid, true);\n            throw e;\n        }\n    };\n\n    sock.groupPromote = async (jid, participants) => {\n        if (!jid.endsWith(\"@g.us\")) return \"Only for Group\";\n        try {\n            let cachedData = groupCache.get(jid);\n            if (!cachedData) {\n                cachedData = await groupCache.fetch(sock, jid);\n            }\n\n            const result = await sock.groupParticipantsUpdate(\n                jid,\n                participants,\n                \"promote\"\n            );\n\n            await groupCache.fetch(sock, jid, true);\n            return result;\n        } catch (e) {\n            console.error(\"Failed to promote participants:\", e.message);\n\n            await groupCache.fetch(sock, jid, true);\n            throw e;\n        }\n    };\n\n    sock.groupDemote = async (jid, participants) => {\n        if (!jid.endsWith(\"@g.us\")) return \"Only for Group\";\n        try {\n            let cachedData = groupCache.get(jid);\n            if (!cachedData) {\n                cachedData = await groupCache.fetch(sock, jid);\n            }\n\n            const result = await sock.groupParticipantsUpdate(\n                jid,\n                participants,\n                \"demote\"\n            );\n\n            await groupCache.fetch(sock, jid, true);\n            return result;\n        } catch (e) {\n            console.error(\"Failed to demote participants:\", e.message);\n\n            await groupCache.fetch(sock, jid, true);\n            throw e;\n        }\n    };\n\n    sock.updateGroupSubject = async (jid, subject) => {\n        if (!jid.endsWith(\"@g.us\")) return \"Only for Group\";\n        try {\n            let cachedData = groupCache.get(jid);\n            if (!cachedData) {\n                cachedData = await groupCache.fetch(sock, jid);\n            }\n\n            groupCache.updateSubject(jid, subject);\n\n            const result = await sock.groupUpdateSubject(jid, subject);\n\n            await groupCache.fetch(sock, jid, true);\n            return result;\n        } catch (e) {\n            console.error(\"Failed to update group subject:\", e.message);\n\n            await groupCache.fetch(sock, jid, true);\n            throw e;\n        }\n    };\n\n    sock.updateGroupDescription = async (jid, description) => {\n        if (!jid.endsWith(\"@g.us\")) return \"Only for Group\";\n        try {\n            let cachedData = groupCache.get(jid);\n            if (!cachedData) {\n                cachedData = await groupCache.fetch(sock, jid);\n            }\n\n            const result = await sock.groupUpdateDescription(jid, description);\n\n            await groupCache.fetch(sock, jid, true);\n            return result;\n        } catch (e) {\n            console.error(\"Failed to update group description:\", e.message);\n\n            await groupCache.fetch(sock, jid, true);\n            throw e;\n        }\n    };\n\n    sock.leaveGroup = async jid => {\n        if (!jid.endsWith(\"@g.us\")) return \"Only for Group\";\n        try {\n            const result = await sock.groupLeave(jid);\n\n            groupCache.delete(jid);\n            return result;\n        } catch (e) {\n            console.error(\"Failed to leave group:\", e.message);\n            throw e;\n        }\n    };\n\n    sock.updateGroupSettings = async (jid, adminsOnly) => {\n        if (!jid.endsWith(\"@g.us\")) return \"Only for Group\";\n        try {\n            let cachedData = groupCache.get(jid);\n            if (!cachedData) {\n                cachedData = await groupCache.fetch(sock, jid);\n            }\n\n            const result = await sock.groupSettingUpdate(\n                jid,\n                adminsOnly ? \"announcement\" : \"not_announcement\"\n            );\n\n            await groupCache.fetch(sock, jid, true);\n            return result;\n        } catch (e) {\n            console.error(\"Failed to update group settings:\", e.message);\n\n            await groupCache.fetch(sock, jid, true);\n            throw e;\n        }\n    };\n\n    return sock;\n}\n\nexport default extendSocket;\n\nlib/upload.js:\nimport axios from \"axios\";\nimport { fileTypeFromBuffer } from \"file-type\";\n\nexport default async (buffer) => {\n    const { ext, mime } = await fileTypeFromBuffer(buffer);\n    \n    const r = (Math.random() + 1).toString(36).substring(2);\n    const filename = r + \".\" + ext;\n    \n    try {\n        const formData = new FormData();\n        const blob = new Blob([buffer], { type: mime });\n        formData.append(\"file\", blob, filename);\n\n        const response = await axios.post(\n            \"https://ikyy-upload-file.hf.space/upload\",\n            formData,\n            {\n                headers: {\n                    \"Content-Type\": \"multipart/form-data\"\n                }\n            }\n        );\n\n        return response.data.fileUrl;\n\n    } catch (e) {\n        console.log(\"Error uploading to ikyy:\", e);\n        return false;\n    }\n};\n\nlib/gemini.js:\nimport axios from \"axios\";\nimport { fileTypeFromBuffer } from \"file-type\";\n\nconst API_URL = \"https://firebasevertexai.googleapis.com/v1beta\";\nconst MODEL_URL =\n    \"projects/gemmy-ai-bdc03/locations/us-central1/publishers/google/models\";\nconst MODEL = \"gemini-2.5-pro\";\nconst HEADERS = {\n    \"content-type\": \"application/json\",\n    \"x-goog-api-client\": \"gl-kotlin/2.1.0-ai fire/16.5.0\",\n    \"x-goog-api-key\": \"AIzaSyD6QwvrvnjU7j-R6fkOghfIVKwtvc7SmLk\"\n};\n\n/**\n *\n * @param {Array<{role: \"system\"|\"user\"|\"assistant\", content: string}>} messages\n * @param {Buffer|null} fileBuffer\n * @returns\n */\nasync function chat(messages = [], fileBuffer = null) {\n    if (!Array.isArray(messages) || messages.length === 0) {\n        throw new Error(\"Messages array is required\");\n    }\n\n    const contents = messages.map(msg => ({\n        role: msg.role === \"system\" ? \"model\" : msg.role,\n        parts: [{ text: msg.content }]\n    }));\n\n    if (fileBuffer) {\n        const type = await fileTypeFromBuffer(fileBuffer);\n        if (!type) throw new Error(\"Unable to detect file type\");\n\n        const inlinePart = {\n            inlineData: {\n                mimeType: type.mime,\n                data: fileBuffer.toString(\"base64\")\n            }\n        };\n\n        const lastUser = [...contents].reverse().find(m => m.role === \"user\");\n        if (lastUser) {\n            lastUser.parts.unshift(inlinePart);\n        } else {\n            contents.push({\n                role: \"user\",\n                parts: [inlinePart]\n            });\n        }\n    }\n\n    const r = await axios.post(\n        `${API_URL}/${MODEL_URL}/${MODEL}:generateContent`,\n        {\n            model: `${MODEL_URL}/${MODEL}`,\n            contents,\n            generationConfig: {\n                mediaResolution: \"MEDIA_RESOLUTION_MEDIUM\"\n            },\n            safetySettings: [\n                {\n                    category: \"HARM_CATEGORY_HARASSMENT\",\n                    threshold: \"BLOCK_NONE\"\n                },\n                {\n                    category: \"HARM_CATEGORY_HATE_SPEECH\",\n                    threshold: \"BLOCK_NONE\"\n                },\n                {\n                    category: \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n                    threshold: \"BLOCK_NONE\"\n                },\n                {\n                    category: \"HARM_CATEGORY_DANGEROUS_CONTENT\",\n                    threshold: \"BLOCK_NONE\"\n                }\n            ],\n            tools: [{ googleSearch: {} }]\n        },\n        { headers: HEADERS }\n    );\n\n    if (r.status !== 200) throw new Error(\"No result found\");\n    return r.data.candidates[0].content.parts.map(o => o.text).join(\"\");\n}\n\nexport default chat;\n\nconfig.js:\nexport default {\n    SESSION: \"session\",\n    PAIRING_CODE: \"IKYYSELF\",\n    PREFIX: [\".\", \"!\", \"/\"],\n    BOT_NAME: \"IKYY\",\n    OWNER_NAME: \"IKYYOFC\",\n    SESSION_CLEANUP_INTERVAL: 1, // jam\n    SESSION_MAX_SIZE_MB: 3 // size folder\n};\n\n\nindex.js:\nimport { fileURLToPath } from 'url';\nimport { join, dirname } from 'path';\nimport { createInterface } from 'readline';\nimport { setupMaster, fork } from 'cluster';\nimport { watchFile, unwatchFile, readFileSync } from 'fs';\n\nconst rl = createInterface(process.stdin, process.stdout);\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n\n// Simple banner tanpa library\nconsole.log('\\n');\nconsole.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\nconsole.log('     ü§ñ LIGHTWEIGHT WHATSAPP BOT ü§ñ    ');\nconsole.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\n\n// Baca package.json manual\ntry {\n  const pkg = JSON.parse(readFileSync(join(__dirname, './package.json'), 'utf-8'));\n  console.log(`     üì¶ ${pkg.name || 'WhatsApp Bot'}`);\n  console.log(`     üë§ By @${pkg.author?.name || pkg.author || 'Unknown'}`);\n} catch (e) {\n  console.log('     üì¶ WhatsApp Bot');\n}\n\nconsole.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\\n');\nconsole.log('üêæ Starting...\\n'); \n\nvar isRunning = false;\n\n/**\n * Start a js file\n * @param {String} file `path/to/file`\n */\nfunction start(file) {\n  if (isRunning) return;\n  isRunning = true;\n\n  let args = [join(__dirname, file), ...process.argv.slice(2)];\n  console.log(`\\nüöÄ Running: ${args.join(' ')}\\n`);\n\n  setupMaster({ exec: args[0], args: args.slice(1) });\n  let p = fork();\n\n  p.on('message', data => {\n    console.log('[‚úÖ RECEIVED]', data);\n    switch (data) {\n      case 'reset':\n        p.kill();\n        isRunning = false;\n        start(file);\n        break;\n      case 'uptime':\n        p.send(process.uptime());\n        break;\n      default:\n        console.warn('[‚ö†Ô∏è UNRECOGNIZED MESSAGE]', data);\n    }\n  });\n\n  p.on('exit', (_, code) => {\n    isRunning = false;\n    console.error('[‚ùó] Exited with code:', code);\n    \n    if (code !== 0) {\n      console.log('[üîÑ] Restarting worker due to non-zero exit code...\\n');\n      return start(file);\n    }\n\n    watchFile(args[0], () => {\n      unwatchFile(args[0]);\n      start(file);\n    });\n  });\n\n  // Simple args parser tanpa yargs\n  const hasTestFlag = process.argv.includes('--test') || process.argv.includes('-t');\n\n  if (!hasTestFlag) {\n    if (!rl.listenerCount()) {\n      rl.on('line', line => {\n        p.emit('message', line.trim());\n      });\n    }\n  }\n}\n\nstart('bot.js');\n\n\ncontoh pembuatan plugins:\n\nexport default async function ({ ...context }) {\n  //logic\n }\n\nkode diatas adalah contoh plugin bot wa (tipe ESM) yang kamu gunakan sebagai referensi jika saya meminta membuatkan suatu plugins baru\n\ningatlah untuk membuat plugin yang simpel, efisien, dan minimalis tetapi fungsinya jelas dan terstruktur dengan baik.\n\nATURAN PENTING YANG HARUS DI INGAT!!!!!\nGAUSAH KASIH FEEDBACK DAN REACT GAJELAS DI PLUGINS NYA, LANGSUNG KASIH HASILNYA AJA!!!!\nHARUS SELALU GUNAKAN TIPE ESM DAN FORMAT ARTIFACT!!!!!",
  };

  if (fileBuffer) {
    try {
      const imageUrl = await upload(fileBuffer);
      if (imageUrl) {
        payload.imageUrl = imageUrl;
      } else {
        // Jika gagal mengunggah, lanjutkan tanpa gambar.
        console.error("Gagal mengunggah gambar untuk Claude API.");
      }
    } catch (e) {
      console.error("Terjadi kesalahan saat mengunggah gambar untuk Claude API:", e);
      // Lanjutkan tanpa gambar jika ada error saat upload
    }
  }

  try {
    const response = await axios.post(
      "https://api.nekolabs.my.id/ai/claude/sonnet-4",
      payload,
      {
        headers: {
          "Content-Type": "application/json",
        },
      }
    );

    if (response.data && response.data.success) {
      await reply(response.data.result);
    } else {
      console.error("Claude API mengembalikan kesalahan atau tidak ada hasil:", response.data);
      await reply("Terjadi kesalahan dari API atau tidak ada hasil yang ditemukan.");
    }
  } catch (error) {
    console.error("Error saat memanggil Claude API:", error);
    await reply(`Terjadi kesalahan saat berkomunikasi dengan AI: ${error.message}`);
  }
}


function extractCodeFromMarkdown(text) {
  // Regex untuk menangkap kode di dalam markdown code block
  const regex = /```(?:javascript|js)?\s*\n([\s\S]*?)```/g;
  
  // Ambil semua kode yang ditemukan
  const matches = [];
  let match;
  
  while ((match = regex.exec(text)) !== null) {
    matches.push(match[1].trim());
  }
  
  // Jika hanya ada satu code block, return string
  // Jika lebih dari satu, return array
  return matches.length === 1 ? matches[0] : matches;
}